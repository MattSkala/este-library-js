// Generated by github.com/steida/coffee2closure 0.0.14
/**
  @fileoverview Base class for classes using events.
*/
goog.provide('este.Base');
goog.require('goog.asserts');
goog.require('goog.events.EventHandler');
goog.require('goog.events.EventTarget');

/**
  @constructor
  @extends {goog.events.EventTarget}
*/
este.Base = function() {
  este.Base.superClass_.constructor.call(this);
}
goog.inherits(este.Base, goog.events.EventTarget);

/**
  @type {goog.events.EventHandler}
  @private
*/
este.Base.prototype.handler_ = null;

/**
  @type {Array.<este.Base>}
  @private
*/
este.Base.prototype.parents_ = null;

/**
  Alias for .listen.
  @param {goog.events.ListenableType} src Event source.
  @param {string|Array.<string>} type Event type to listen for or array of
    event types.
  @param {Function|Object=} fn Optional callback function to be used as
    the listener or an object with handleEvent function.
  @param {boolean=} capture Optional whether to use capture phase.
  @param {Object=} handler Object in whose scope to call the listener.
  @protected
*/
este.Base.prototype.on = function(src, type, fn, capture, handler) {
  return this.getHandler().listen(src, type, fn, capture, handler);
};

/**
  Alias for .listenOnce.
  @param {goog.events.ListenableType} src Event source.
  @param {string|Array.<string>} type Event type to listen for or array of
    event types.
  @param {Function|Object=} fn Optional callback function to be used as
    the listener or an object with handleEvent function.
  @param {boolean=} capture Optional whether to use capture phase.
  @param {Object=} handler Object in whose scope to call the listener.
  @protected
*/
este.Base.prototype.once = function(src, type, fn, capture, handler) {
  return this.getHandler().listenOnce(src, type, fn, capture, handler);
};

/**
  Alias for .unlisten.
  @param {goog.events.ListenableType} src Event source.
  @param {string|Array.<string>} type Event type to listen for or array of
    event types.
  @param {Function|Object=} fn Optional callback function to be used as
    the listener or an object with handleEvent function.
  @param {boolean=} capture Optional whether to use capture phase.
  @param {Object=} handler Object in whose scope to call the listener.
  @protected
*/
este.Base.prototype.off = function(src, type, fn, capture, handler) {
  return this.getHandler().unlisten(src, type, fn, capture, handler);
};

/**
  Add parent for dispatch event.
  @param {este.Base} parent
  @protected
*/
este.Base.prototype.addParent = function(parent) {
  return goog.array.insert(this.getParents(), parent);
};

/**
  Remove parent for dispatch event.
  @param {este.Base} parent
  @return {boolean} True if a parent was removed.
  @protected
*/
este.Base.prototype.removeParent = function(parent) {
  return goog.array.remove(this.getParents(), parent);
};

/**
  Return dispatch event parents.
  @return {Array.<este.Base>}
  @protected
*/
este.Base.prototype.getParents = function() {
  return this.parents_ || (this.parents_ = []);
};

/**
  @protected
*/
este.Base.prototype.getHandler = function() {
  return this.handler_ != null ? this.handler_ : this.handler_ = new goog.events.EventHandler(this);
};

/**
  Dispatch event on instance itself and also on its parents. Useful when one
  model is placed in several collection. It enabled multi-parent events
  bubbling.
  @override
*/
este.Base.prototype.dispatchEvent = function(e) {
  var parent, parentResult, result, _i, _len, _ref;
  result = este.Base.superClass_.dispatchEvent.call(this, e);
  if (!this.parents_) {
    return result;
  }
  _ref = this.getParents().slice(0);
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    parent = _ref[_i];
    parentResult = parent.dispatchEvent(e);
    if (parentResult === false) {
      result = false;
    }
  }
  return result;
};

/**
  @override
*/
este.Base.prototype.disposeInternal = function() {
  var _ref;
  if ((_ref = this.handler_) != null) {
    _ref.dispose();
  }
  this.parents_ = null;
  este.Base.superClass_.disposeInternal.call(this);
};