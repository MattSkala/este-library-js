// Generated by github.com/steida/coffee2closure 0.0.14
/**
  @fileoverview We use models for descripting our app core business logic.
  Model is single source of truth. Subclassing from este.Model allow us to
  listen model changes and validate model state too.
*/
goog.provide('este.demos.mvc.closureTemplates.Model');
goog.require('este.Model');

/**
  @param {Object=} json Optional JSON to fulfil model.
  @constructor
  @extends {este.Model}
*/
este.demos.mvc.closureTemplates.Model = function(json) {
  este.demos.mvc.closureTemplates.Model.superClass_.constructor.call(this, json);
}
goog.inherits(este.demos.mvc.closureTemplates.Model, este.Model);

/**
  This property is used for este.storage.* to autogenerate model endpoint.
  @override
*/
este.demos.mvc.closureTemplates.Model.prototype.url = '/todos';

/**
  Describe default model state.
  @override
*/
este.demos.mvc.closureTemplates.Model.prototype.defaults = {
  'title': ''
};

/**
  Define valid model state. Angular and other HTML first oriented frameworks
  put their validation rules into HTML, but such approach does not scale.
  Imagine you have two or more views of one model. You would have to repeat
  model's validation rules everywhere in HTML.
  @override
*/
este.demos.mvc.closureTemplates.Model.prototype.schema = {
  'title': {
    'set': este.model.setters.trim,
    'validators': [este.validators.required()]
  }
};