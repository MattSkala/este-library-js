// Generated by github.com/steida/coffee2closure 0.0.14
suite('este.Model', function() {
  var  RequiredValidator, json, person, requiredValidator, trimSetter;
  trimSetter = function(value) {
    return goog.string.trim(value || '');
  };
  RequiredValidator = function() {};
  RequiredValidator.prototype.isValidable = function() {
    return true;
  };
  RequiredValidator.prototype.validate = function() {
    switch (goog.typeOf(this.value)) {
      case 'string':
        return goog.string.trim(this.value + '').length > 0;
      case 'array':
        return this.value.length > 0;
      default:
        return this.value != null;
    }
  };
  requiredValidator = function() {
    return new RequiredValidator;
  };
  var Person = function(json, randomStringGenerator) {
    Person.superClass_.constructor.call(this, json, randomStringGenerator);
  }
  goog.inherits(Person, este.Model);
  Person.prototype.defaults = {
    'title': '',
    'defaultFoo': 1
  };
  Person.prototype.schema = {
    'firstName': {
      'set': trimSetter,
      'validators': [requiredValidator]
    },
    'lastName': {
      'validators': [requiredValidator]
    },
    'name': {
      'meta': function(self) {
        return self.get('firstName') + ' ' + self.get('lastName');
      }
    },
    'age': {
      'get': function(age) {
        return Number(age);
      }
    }
  };
  json = null;
  person = null;
  setup(function() {
    var idGenerator;
    json = {
      'firstName': 'Joe',
      'lastName': 'Satriani',
      'age': '55'
    };
    idGenerator = function() {
      return 1;
    };
    return person = new Person(json, idGenerator);
  });
  suite('constructor', function() {
    test('should work', function() {
      return assert.instanceOf(person, Person);
    });
    test('should assign _cid', function() {
      return assert.equal(person.get('_cid'), 1);
    });
    test('should assign id', function() {
      person = new Person({
        'id': 'foo'
      });
      assert.equal(person.get('id'), 'foo');
      return assert.equal(person.getId(), 'foo');
    });
    test('should create attributes', function() {
      person = new Person;
      return assert.isUndefined(person.get('firstName'));
    });
    test('should return passed attributes', function() {
      assert.equal(person.get('firstName'), 'Joe');
      assert.equal(person.get('lastName'), 'Satriani');
      return assert.equal(person.get('age'), 55);
    });
    test('should set defaults', function() {
      assert.equal(person.get('defaultFoo'), 1);
      return assert.strictEqual(person.get('title'), '');
    });
    return test('should set defaults before json', function() {
      person = new Person({
        'defaultFoo': 2
      });
      return assert.equal(person.get('defaultFoo'), 2);
    });
  });
  suite('instance', function() {
    return test('should have string url property', function() {
      return assert.isString(person.url);
    });
  });
  suite('set and get', function() {
    test('should work for one attribute', function() {
      person.set('age', 35);
      return assert.strictEqual(person.get('age'), 35);
    });
    return test('should work for attributes', function() {
      person.set({
        'age': 35,
        'firstName': 'Pepa'
      });
      assert.strictEqual(person.get('age'), 35);
      return assert.strictEqual(person.get('firstName'), 'Pepa');
    });
  });
  suite('get', function() {
    return test('should accept array and return object', function() {
      return assert.deepEqual(person.get(['age', 'firstName']), {
        'age': 55,
        'firstName': 'Joe'
      });
    });
  });
  suite('toJson', function() {
    suite('true', function() {
      test('should return undefined name and _cid for model', function() {
        json = person.toJson(true);
        return assert.deepEqual(json, {
          'title': '',
          'firstName': 'Joe',
          'lastName': 'Satriani',
          'age': '55',
          'defaultFoo': 1
        });
      });
      return test('should return undefined name and _cid for empty model', function() {
        person = new Person;
        json = person.toJson(true);
        return assert.deepEqual(json, {
          'title': '',
          'defaultFoo': 1
        });
      });
    });
    suite('false', function() {
      test('should return name and _cid for model', function() {
        json = person.toJson();
        return assert.deepEqual(json, {
          '_cid': 1,
          'title': '',
          'firstName': 'Joe',
          'lastName': 'Satriani',
          'name': 'Joe Satriani',
          'age': 55,
          'defaultFoo': 1
        });
      });
      return test('should return name and _cid for empty model', function() {
        person = new Person(null, function() {
          return 1;
        });
        json = person.toJson();
        return assert.deepEqual(json, {
          '_cid': 1,
          'title': '',
          'name': 'undefined undefined',
          'defaultFoo': 1
        });
      });
    });
    suite('on model with attribute with toJson too', function() {
      test('should serialize attribute too', function() {
        var cid, innerModel, model;
        cid = 0;
        model = new este.Model(null, function() {
          return ++cid;
        });
        innerModel = new este.Model(null, function() {
          return 1;
        });
        innerModel.set('b', 'c');
        model.set('a', innerModel);
        return assert.deepEqual(model.toJson(), {
          _cid: 1,
          a: {
            _cid: 1,
            b: 'c'
          }
        });
      });
      return test('should raw serialize attribute too', function() {
        var cid, innerModel, model;
        cid = 0;
        model = new este.Model(null, function() {
          return ++cid;
        });
        innerModel = new este.Model(null, function() {
          return 1;
        });
        innerModel.set('b', 'c');
        model.set('a', innerModel);
        return assert.deepEqual(model.toJson(true), {
          a: {
            b: 'c'
          }
        });
      });
    });
    return test('should be possible to set null or undefined value', function() {
      person.set('title', null);
      person.set('defaultFoo', void 0);
      json = person.toJson(true);
      return assert.deepEqual(json, {
        'title': null,
        'firstName': 'Joe',
        'lastName': 'Satriani',
        'age': '55',
        'defaultFoo': void 0
      });
    });
  });
  suite('has', function() {
    test('should work', function() {
      assert.isTrue(person.has('age'));
      return assert.isFalse(person.has('fooBlaBlaFoo'));
    });
    test('should work even for keys which are defined on Object.prototype.', function() {
      assert.isFalse(person.has('toString'));
      assert.isFalse(person.has('constructor'));
      return assert.isFalse(person.has('__proto__'));
    });
    return test('should work for meta properties too', function() {
      return assert.isTrue(person.has('name'));
    });
  });
  suite('remove', function() {
    return test('should work', function() {
      assert.isFalse(person.has('fok'));
      assert.isFalse(person.remove('fok'));
      assert.isTrue(person.has('age'));
      assert.isTrue(person.remove('age'));
      return assert.isFalse(person.has('age'));
    });
  });
  suite('schema', function() {
    suite('set', function() {
      return test('should work as formater before set', function() {
        person.set('firstName', '  whitespaces ');
        return assert.equal(person.get('firstName'), 'whitespaces');
      });
    });
    return suite('get', function() {
      return test('should work as formater after get', function() {
        person.set('age', '1d23');
        return assert.isNumber(person.get('age'));
      });
    });
  });
  suite('change event', function() {
    test('should be dispatched if value change', function(done) {
      goog.events.listen(person, 'change', function(e) {
        assert.deepEqual(e.changed, {
          age: 'foo'
        });
        assert.equal(e.model, person);
        return done();
      });
      return person.set('age', 'foo');
    });
    test('should not be dispatched if value hasnt changed', function() {
      var called;
      called = false;
      goog.events.listen(person, 'change', function(e) {
        return called = true;
      });
      person.set('age', 55);
      return assert.isFalse(called);
    });
    return test('should be dispatched if value is removed', function() {
      var called;
      called = false;
      goog.events.listen(person, 'change', function(e) {
        return called = true;
      });
      person.remove('age');
      return assert.isTrue(called);
    });
  });
  suite('update event', function() {
    test('should be dispatched if value change', function(done) {
      goog.events.listen(person, 'update', function(e) {
        return done();
      });
      return person.set('age', 'foo');
    });
    test('should not be dispatched if value hasnt changed', function() {
      var called;
      called = false;
      goog.events.listen(person, 'update', function(e) {
        return called = true;
      });
      person.set('age', 55);
      return assert.isFalse(called);
    });
    return test('should be dispatched if value is removed', function() {
      var called;
      called = false;
      goog.events.listen(person, 'update', function(e) {
        return called = true;
      });
      person.remove('age');
      return assert.isTrue(called);
    });
  });
  suite('meta', function() {
    return test('should define meta attribute', function() {
      return assert.equal(person.get('name'), 'Joe Satriani');
    });
  });
  suite('bubbling events', function() {
    test('from inner model should work', function() {
      var called, innerModel;
      called = 0;
      innerModel = new Person;
      person.set('inner', innerModel);
      goog.events.listen(person, 'change', function(e) {
        return called++;
      });
      innerModel.set('name', 'foo');
      person.remove('inner', innerModel);
      innerModel.set('name', 'foo');
      return assert.equal(called, 2);
    });
    return test('from inner model (within other model) should work', function() {
      var called, innerModel, someOtherPerson;
      called = 0;
      innerModel = new Person;
      someOtherPerson = new Person;
      person.set('inner', innerModel);
      someOtherPerson.set('inner', innerModel);
      goog.events.listen(person, 'change', function(e) {
        return called++;
      });
      innerModel.set('name', 'foo');
      person.remove('inner', innerModel);
      innerModel.set('name', 'foo');
      return assert.equal(called, 2);
    });
  });
  suite('errors', function() {
    suite('validate', function() {
      return test('should return correct errors', function() {
        var errors;
        errors = person.validate();
        assert.isNull(errors);
        person = new Person;
        errors = person.validate();
        assert.isArray(errors);
        assert.lengthOf(errors, 2);
        assert.instanceOf(errors[0], RequiredValidator);
        assert.instanceOf(errors[1], RequiredValidator);
        assert.equal(errors[0].model, person);
        assert.equal(errors[0].key, 'firstName');
        assert.equal(errors[0].value, void 0);
        assert.equal(errors[1].model, person);
        assert.equal(errors[1].key, 'lastName');
        assert.equal(errors[1].value, void 0);
        person.set('firstName', 'Pepa');
        errors = person.validate();
        assert.lengthOf(errors, 1);
        assert.instanceOf(errors[0], RequiredValidator);
        assert.equal(errors[0].model, person);
        assert.equal(errors[0].key, 'lastName');
        return assert.equal(errors[0].value, void 0);
      });
    });
    return suite('inner validate', function() {
      return test('should return correct errors', function() {
        var a, b, errors;
        a = new este.Model;
        b = new este.Model;
        b.schema = {
          'title': {
            'validators': [este.validators.required()]
          }
        };
        a.set('b', b);
        errors = a.validate();
        assert.lengthOf(errors, 1);
        a.remove('b');
        errors = a.validate();
        return assert.isNull(errors);
      });
    });
  });
  suite('idAttribute', function() {
    return test('should allow to define alternate id', function() {
      person = new Person;
      person.idAttribute = '_id';
      person.setId('123');
      return assert.equal(person.getId(), '123');
    });
  });
  suite('createUrl', function() {
    suite('without collection', function() {
      test('should work for model without id', function() {
        return assert.equal(person.createUrl(), '/models');
      });
      test('should work for model with id', function() {
        person.setId(123);
        return assert.equal(person.createUrl(), '/models/123');
      });
      return test('should work for model with url defined as function', function() {
        person.url = function() {
          return '/foos';
        };
        person.setId(123);
        return assert.equal(person.createUrl(), '/foos/123');
      });
    });
    return suite('with collection', function() {
      test('should work for model without id', function() {
        var collection;
        collection = {
          getUrl: function() {
            return '/todos';
          }
        };
        return assert.equal(person.createUrl(collection), '/todos');
      });
      return test('should work for model with id', function() {
        var collection;
        person.setId(123);
        collection = {
          getUrl: function() {
            return '/todos';
          }
        };
        return assert.equal(person.createUrl(collection), '/todos/123');
      });
    });
  });
  suite('setId', function() {
    test('should be immutable if defined in constructor then again', function(done) {
      var e;
      person = new Person({
        'id': 'foo'
      });
      try {
        return person.setId('bla');
      } catch (_error) {
        e = _error;
        return done();
      }
    });
    return test('should be immutable if defined twice', function(done) {
      var e;
      person = new Person;
      person.setId('foo');
      try {
        return person.setId('bla');
      } catch (_error) {
        e = _error;
        return done();
      }
    });
  });
  suite('getId', function() {
    test('should return empty string for model without id', function() {
      return assert.equal(person.getId(), '');
    });
    return test('should return string id for model with id', function() {
      person.setId(123);
      return assert.equal(person.getId(), '123');
    });
  });
  suite('nested idAttribute', function() {
    test('should allow to set nested mongodb like id via set method', function() {
      var model;
      model = new este.Model;
      model.idAttribute = '_id.$oid';
      model.set({
        '_id': {
          '$oid': 123
        }
      });
      return assert.equal(model.getId(), '123');
    });
    return test('should allow to set nested mongodb like id via setId method', function() {
      var model;
      model = new este.Model;
      model.idAttribute = '_id.$oid';
      model.setId(123);
      assert.equal(model.getId(), '123');
      return assert.deepEqual(model.toJson(true), {
        '_id': {
          '$oid': 123
        }
      });
    });
  });
  suite('Model.equal', function() {
    return test('should work', function() {
      var model1, model2;
      assert.isTrue(este.Model.equal(null, null));
      assert.isTrue(este.Model.equal(void 0, void 0));
      assert.isTrue(este.Model.equal(1, 1));
      assert.isFalse(este.Model.equal(1, 2));
      model1 = new este.Model({
        a: 1
      }, function() {
        return 1;
      });
      model2 = new este.Model({
        a: 1
      }, function() {
        return 1;
      });
      assert.isTrue(este.Model.equal(model1, model2));
      model1 = {
        a: '1'
      };
      model2 = {
        a: '1'
      };
      assert.isTrue(este.Model.equal(model1, model2));
      model1 = {
        a: '1'
      };
      model2 = {
        a: '2'
      };
      assert.isFalse(este.Model.equal(model1, model2));
      model1 = [1];
      model2 = [1];
      assert.isTrue(este.Model.equal(model1, model2));
      model1 = [1];
      model2 = [2];
      return assert.isFalse(este.Model.equal(model1, model2));
    });
  });
  suite('defaults', function() {
    test('should be possible to use function instead of value', function() {
      var  foo;
      var Foo = function() {
        Foo.superClass_.constructor.apply(this, arguments);
      }
      goog.inherits(Foo, este.Model);
      Foo.prototype.defaults = {
        'title': function() {
          return 'foo';
        }
      };
      foo = new Foo;
      return assert.equal(foo.get('title'), 'foo');
    });
    return test('should deeply clone non primitive defaults', function() {
      var  a, aSerialized, b, bSerialized;
      var Foo = function() {
        Foo.superClass_.constructor.call(this);
      }
      goog.inherits(Foo, este.Model);
      Foo.prototype.defaults = {
        'array': [[]],
        'object': {
          foo: {
            bla: 1
          }
        }
      };
      a = new Foo;
      b = new Foo;
      b.get('array').push('foo');
      b.get('object').bar = 1;
      aSerialized = JSON.stringify(a.toJson(true));
      bSerialized = JSON.stringify(b.toJson(true));
      assert.equal(aSerialized, '{"array":[[]],"object":{"foo":{"bla":1}}}');
      return assert.equal(bSerialized, '{"array":[[],"foo"],"object":{"foo":{"bla":1},"bar":1}}');
    });
  });
  suite('getClone', function() {
    return test('should return cloned value', function() {
      var roles;
      roles = ['admin', 'user'];
      person.set('roles', roles);
      assert.deepEqual(roles, person.getClone('roles'));
      assert.notEqual(roles, person.getClone('roles'));
      person.getClone('roles').push('superuser');
      return assert.deepEqual(roles, person.getClone('roles'));
    });
  });
  suite('inNew', function() {
    test('should return true for model without ID', function() {
      return assert.isTrue(person.isNew());
    });
    return test('should return false for model with ID', function() {
      person.set('id', 123);
      return assert.isFalse(person.isNew());
    });
  });
  return suite('set', function() {
    return test('should accept function for setting complex values', function(done) {
      person.set('array', []);
      goog.events.listenOnce(person, 'change', function(e) {
        assert.deepEqual({
          array: [1]
        }, e.changed);
        assert.deepEqual([1], person.get('array'));
        return done();
      });
      return person.set('array', function(array) {
        return array.push(1);
      });
    });
  });
});